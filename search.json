[
  
    {

      "title"    : "Naming Guidelines",
      "url"      : "/posts/Naming-Guidelines",
      "content"  : "Programming is a team sport where we use code to send messages of intent to our future selves.\nThe messages are the names we have assigned to various function, class and other code elements.\nThe assigned name can then help our future selves figure out the intent of an element and if a new piece of functionality goes here or over there.\nThus naming is inseparable from design.\nA well-chosen name is the difference between one hour of \"I know exactly what to do\" and days and weeks of rework because \"I thought I needed to do this but actually&#8230;&#8203;\".\n\n\n\n\nThere are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors.\n\n\n\n&#8212; Leon Bambrick\n\n\n\nTrue to the above quote I still find namings things very hard.\nFortunately Bob Nystrom has written two great blog posts on the subject: Long Names are Long and Naming Things in Code.\nThese two describe guidelines for naming which I want to reiterate, extend and sometimes even change.\nMost of the stuff I&#8217;ve added are ideas from the community (f.ex. Johannes Seitz).\nI&#8217;m not making any originality vows here :)\n\n\nIn a future post I&#8217;d also like to take a look at Arlo Belshee&#8217;s \"Naming is a Process\" which describes the process of coming up with a good name.\n\n\n\n\n\nNote\n\n\n\nIf you know about even more great articles, books, etc. please consider contacting me using Twitter and the like.\n\n\n\n\n\n\nGood Names\n\n\nA name has one goal:\n\n\n\n\nIt needs to reveal the authors intention (see Kent Beck&#8217;s Four Rules of Simple Design). Which means:\n\n\n\nIt needs to be clear: you need to know what the name refers to (Long Names are Long).\n\n\nIt needs to be precise: you need to know what it does not refer to (Long Names are Long).\n\n\n\n\n\n\n\nOnce a name has accomplished its goal, any additional characters are redundant.\n\n\nThe following guidelines will help us write terse code that communicates intention.\n\n\nUse one word per concept\n\n\n\n&#10003; Use one word per concept.\n\n\n// Bad (three variations for the same concept: fetching accounts):\nfun fetchActiveAccount(): List&lt;Account&gt;\nfun allActiveAccounts(): List&lt;Account&gt;\nfun retrieveActiveAccountInfo(): List&lt;Account&gt;\n// Better\nfun allActiveAccounts(): List&lt;Account&gt;\n\n\n\n\n\n\n\nOmit words that are obvious given a variable’s or parameter’s type\n\n\n\n&#10003; Don&#8217;t put the type in the variable’s name\n\n\n// Bad:\nval integerId: Int\nval nameString: String\n// Better\nval id: Int\nval name: String\n\n\n\n\n&#10003; Pair Numbers and their unit (5 meter, 20 seconds, 5 €) so you can never pass seconds to a method that expects milliseconds (length class in the appendix)\n\n\n// Bad:\nval lengthInMillis: Int\n// Better\nval length: Length\n\n\n\n\n&#10003; Express concepts with types and avoid stringly typed code.\n\n\n// Bad:\nclass Person constructor(val name: String, val street: String, val zipCode: String, val city: String){ /* */ }\n\n// Better:\nclass Person constructor(val name: Name, val address: Address){ /* */ }\nclass Address constructor(val street: Street, val zipCode: ZipCode, val city: City){ /* */ }\n\n\n\n\n&#10003; Name collections not by their type but what&#8217;s in them using the (forced) plural form.\n\n\n// Bad:\nval personList: List&lt;Person&gt;\nval furnitureList: List&lt;Furniture&gt;\nval dogPersonHashMap: Map&lt;Dog, Person&gt;\n// Better\nval people: List&lt;Person&gt;\nval furnitures: List&lt;Furniture&gt;\nval dogOwners: Map&lt;Dog, Person&gt;\n\n\n\n\n&#10003; Don’t add the argument name to function name. It&#8217;s redundant since our type system and IDE tell us everything we need to know.\n\n\n// Bad:\nfun mergeTableCells(cells: List&lt;TableCell&gt;)\n// Better\nfun merge(cells: List&lt;TableCell&gt;)\n\n\n\n\n\nThis also makes the call easier to read: merge(cells) vs mergeTableCells(tableCells)\n\n\n\n\n\n&#10003; Only describe the return in the name if there are identical functions that return different types.\n\n\n// Bad:\nlist.countInt()\n// Better:\nlist.count()\nmessage.valueAsInt()\nmessage.valueAsFloat()\n\n\n\n\n\n\n\nOmit words that don’t disambiguate the name\n\n\n\nTake a look at recentlyUpdatedAnnualSalesBid\n\n\n\nAre there updated annual sales bids that aren’t recent?\n\n\nAre there recent annual sales bids that were not updated?\n\n\nAre there recently updated sales bids that aren’t annual?\n\n\n\n\n\nAnd so on. We can apply such questioning to all of our names to figure out which words are just fluff, don’t disambiguate the name and should be removed.\n\n\n\n\n\nOmit words that are known from the surrounding context\n\n\n\nClass variables are in the context of their class. Class names are in the context of their component and so on.\n\n\n// Bad:\nclass AnnualHolidaySale constructor(val annualSaleRebate: Rebate){\n    fun promoteHolidaySale() { /* */ }\n}\n\n// Better:\nclass AnnualHolidaySale constructor(val rebate: Rebate){\n    fun promote() { /* */ }\n}\n\n\n\n\n\n\n\nOmit words that don’t mean much of anything\n\n\n\nWe&#8217;re looking at you manager, instance, amount, state etc.\n\n\nConnection provides exactly the same information as ConnectionManager.\n\n\nIf in doubt ask yourself “Would this name mean the same thing if I removed the word?”.\n\n\nNever use set-Methods. The Merriam-Webster dictionary has more than 25 definitions of the verb set. It is one of the least-precise words you can use. Consider using names that express intent and give you the ability to protect invariants.\n\n\n// Bad\ncar.setEngineState(EngineState.On)\ncar.setDestination(London)\n// Better\ncar.start()\ncar.plotCourseTo(London)\n\n\n\n\nNever use get-Methods. The Merriam-Webster dictionary has more than 15 definitions of the verb get. Name functions that just return a property and don’t change state using nouns. Using a get as prefix does not provide any meaningful additional information and is just fluff.\n\n\n// Bad\nobj.getCount()\n// Better\ndogs.count()\n\n\n\n\n\n\n\n\n\nSummary\n\n\n\n\nUse one word per concept\n\n\nOmit words that are obvious given a variable’s or parameter’s type\n\n\nOmit words that don’t disambiguate the name\n\n\nOmit words that are known from the surrounding context\n\n\nOmit words that don’t mean much of anything\n\n\n\n\nI hope these guidelines provide value to you.\nMost of them are from Long Names are Long and I&#8217;ve only added little bits here and there.\n\n\n\n\nAppendix: Length class\n\n\nIt&#8217;s not hard to write a class that pairs a number and a unit.\nI&#8217;ve included an example below with lots of useful methods.\nDepending on your domain a money object can be more challenging because you do have to remember your unit and can&#8217;t convert everything to a default unit.\nPlease also not that I used integer precision for my length.\nDepending on your domain you might want to use long or BigDecimal instead.\n\n\n\n// (you can write this much shorter if you use Kotlin data classes or Java records)\nclass Length private constructor(private val rawValueInMeter: Int): Comparable&lt;Length&gt;{\n    // so that Length(4) == Length(4)\n    override fun equals(other: Any?): Boolean {\n        if(other === this) return true\n        else if(other !is Length) return false\n        else return Objects.equals(rawValueInMeter, other.rawValueInMeter)\n    }\n    // so that you can use Length in a Set or Map\n    override fun hashCode(): Int { return Objects.hash(rawValueInMeter) }\n    // for nicer debugging\n    override fun toString(): String { return \"$rawValueInMeter m\" }\n\n    // so that Length(4) &lt; Length(5)\n    override operator fun compareTo(other: Length): Int = this.rawValueInMeter.compareTo(other.rawValueInMeter)\n    // so that Length(4) + Length(5) = Length(9)\n    operator fun plus(other: Length) = Length(rawValueInMeter + other.rawValueInMeter)\n    // so that Length(8) - Length(5) = Length(3)\n    operator fun minus(other: Length) = Length(rawValueInMeter - other.rawValueInMeter)\n\n    companion object {\n        // so that you can write Length.fromMeter(4) and know the unit\n        fun fromMeter(meter: Int) = Length(meter)\n    }\n}"

    },
  
    {

      "title"    : "Contract Tests in Kotlin",
      "url"      : "/posts/Contract-Tests-in-Kotlin",
      "content"  : "In my current Kotlin project we often have two code elements that implement the same interface.\nWe have InMemoryXyzRepositories that double PostgresXyzRepositories during tests.\nWe also have a GuavaEventBus that we want to switch on when our environment does not provide a KafkaEventBus.\n\n\nHow can we be sure that both pieces of code behave the same way and continue to do so?\nThankfully we found an article on Contract Tests by J. B. Rainsberger.\n\n\nA contract test is a test were you document your understanding of the behavior of an interface.\nTo do this, you need an interface, your favorite test framework and at least one interface implementation.\n\n\nI&#8217;ll demonstrate the idea with some code.\nThe complete code can be found on Github.\n\n\n\nabstract class DogsContract { // (1)\n    protected abstract fun dogs(): Dogs // (2)\n\n    @Test\n    fun `a dog in the repo should be findable by its id`() {\n        // arrange\n        val testling = dogs()\n        val adog = Dog(DogId(\"1\"), \"Spike\")\n        testling.put(adog)\n\n        // act\n        val result = testling.findById(adog.id)\n\n        // assert\n        assertThat(result).isEqualTo(adog)\n    }\n}\n\ninterface Dogs { // (3)\n    fun put(dog: Dog)\n    fun findById(id: DogId): Dog?\n}\n\n\n\n\n\nCreate an abstract contact, where you document your understanding of the behavior\n\n\na way to get your interface implementation; the method might take parameters if you want to initialize your implementation with specific data\n\n\nThe interface for which you create the contract\n\n\n\n\n\n\n\nNote\n\n\nDogs is a repository which can be used to retrieve the domain object Dog.\nI like the convention where the name of the repository is the plural of the domain object for which it is responsible.\nThis keeps my domain clear of technical terms like Repository or Database.\n\n\n\n\n\nAfter you have written your contract, you can write the implementation and the test for the implementation:\n\n\n\nclass InMemoryDogsTest: DogsContract() {\n    override fun dogs(): Dogs { return InMemoryDogs() }\n}\n\nclass InMemoryDogs: Dogs {\n    private val dogs = ConcurrentHashMap&lt;DogId, Dog&gt;(16)\n\n    override fun put(dog: Dog) { dogs.put(dog.id, dog) }\n    override fun findById(id: DogId): Dog? { return dogs.get(id) }\n}\n\n\n\nMaven, Gradle and IntelliJ will run all implementations of DogsContract.\nThe gutter icon in IntelliJ will ask you if you want to run a specific implementation or all of them.\n\n\nI like to put the XyzContract in the same package as the interface and likewise for the XyzTest.\nIf Dogs is in src/main/de.richargh.application, then DogsContract is in src/test/de.richargh.application.\n\n\nI also like to tag my InMemoryDogsTest differently than a RemotePartnerServiceDogsTest.\nThe former gets no annotation because it&#8217;s part of my fast test suite that I want to execute before every commit.\nThe latter gets a @Tag(\"remotepartner\") because I need infrastructure outside my JVM container to run it and I will for the most part let my build pipeline do the executing.\n\n\nThe awesome part is that I can now have two or more implementations of the same interface and they will stay in sync.\nWriting these contract tests does not take much effort on my part\nand they allow me to express contract behavior the same way I express any other behavior."

    },
  

  
    {

      "title"    : "Note Placeholder",
      "url"      : "/notes/Note-Placeholder",
      "content"  : "Without this placeholder no auto-complete is generated."

    }
  
]